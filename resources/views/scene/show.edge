@layout('layouts/master')
@section('css')
<link rel="stylesheet" href="/css/selectize.css">
@endsection
@section('js')
<script src="/js/bulma-dropdown.js"></script>
<script src="/js/bulma-modal.js"></script>
@endsection
@section('content')
<style>
    .saved{
        background-color:#00FF8050;
    }
    
    .lineText{
        margin-bottom:3px;
        overflow:hidden;
    }
    .image-character{
    width:40px;
    height:40px;
    }
   
    .lineContainer{position:relative;}
    @keyframes glowing {
  0% {
    background-color: #fde0e6;
    box-shadow: 0 0 10px #fde0e6;
  }
  50% {
    background-color: #ff0000;
    box-shadow: 0 0 30px #ff0000;
  }
  100% {
    background-color: #fde0e6;
    box-shadow: 0 0 10px #fde0e6;
  }
}

  .glowing {
    animation: glowing 1300ms infinite;
  }
.audioPlayer {
    display: flex;
    justify-content: center;
  align-items: center;
   position: fixed;
   left: 0;
   bottom: 0;
   width: 100%;
   height: 7vh;
   background-color: red;
   color: white;
   text-align: center;
}
.audioPlayer .controls *     {
    display: inline;
}

.controls .play, .controls .pause {
  margin: 15px 25px;
  color: #6e946c;
}
.controls .volume {
  margin-right: 30px;
  font-size: 0.8em;
}
.inline {
  display: inline-block;
}
.vertically-centered {
  display: inline-block;
  vertical-align: middle;
  line-height: normal;
}
</style>





<div class="container">
<div class="level">
    <div class="level-left">
        <div class="level-item">
            <div>
            <h1 class="title">
                {{scene.play.name}}
            </h1>
            </div>
        </div>
    </div>
</div>    
{{--  Select other scene from this play  --}}
    <h2 class="subtitle">
        <div class="select">
            <select name="scene" id="" oninput="window.location.href = '/scenes/'+this.value">
                @each(sceneFromPlay in scene.play.scenes)
                <option value="{{sceneFromPlay.id}}" {{sceneFromPlay.id==scene.id?'selected':''}}>{{sceneFromPlay.name}}</option>
                @endeach
            </select>
        </div>
    </h2>

    <h2 class="subtitle">
        {{scene.description}}
    </h2>
</div>    
    <hr>
    
    {{--  LineContainer  --}}
    
    <div class="level" style="align-items:flex-start">
        <div class="level-item" style="border-left:2px white solid;">
            <div class="lineContainer" style="text-align:center;"> 
                @set('position',null)
                
                @each((line,indexLine) in scene.lines)
                        @if(line.position!=position)
                            @include('partials/scenes/show/newLine')  
                        @endif
                        @set('position',line.position)
                            @include('partials/scenes/show/line')    
                @endeach
            </div>
        </div>
    </div>
    





    <div class="csrfToken" data-csrf-token="{{ csrfToken }}"></div>
    <audio id="player"></audio>
        
    <script>

    ////////////////////
    // GLOBALS
    ////////////////////
        const globalAudios = [];
        const characterToAudioVersion = {};
        let recording = false;
        let mediaRecorder;
        let characterIds=new Set();

    ////////////////////
    // INITIALISATION GLOBALS
    ////////////////////
    $(".selectLineVersion select").each(function(){
            characterIds.add($(this).data('character-id'))
    })
    characterIds.forEach((characterId)=>{updateLineVersion(characterId,1);}); 
    
    ////////////////////
    // LINE VERSION SELECTION
    ////////////////////
        

        $(".selectLineVersion select").on('change',function(e){
            const audioVersionSelect = e.target.closest(".characterSelect").querySelector(".selectAudioVersion select");
            var characterId=$(this).data('character-id');
            var versionId=$(this).val();
            updateLineVersion(characterId,versionId);
        })

        function updateLineVersion(characterId,versionId)
        {
            UpdateDisplaySelectLineVersion(characterId,versionId);
            //if it is a real lineVersion
            if(versionId>0){
                console.log('versionId',versionId);
                UpdateDisplayLineVersion(characterId,versionId);
                getAudioVersion(characterId,versionId)
            }else{
            //if it is 0=>Create a new text alternative
                createNewLineVersion(characterId);
            }
        }
        function UpdateDisplaySelectLineVersion(characterId,versionId){
            $(".characterSelect_"+characterId+" .selectLineVersion select").val(versionId);
        }
        function UpdateDisplayLineVersion(characterId,versionId)
        {
            $(".lineCharacter_"+characterId).hide();
            $(".lineCharacter_"+characterId+".lineVersion_"+versionId).show();
        }
        
        function getAudioVersion(characterId,versionId){
            console.log("getAudioVersion")
            const token = $('.csrfToken').data('csrf-token');
            const params = { 
                characterId,
                versionId,
                sceneId:{{scene.id}},
                _csrf: token
            };
            $.get('/audio/getAudioVersions', params, function(data) {
                console.log("getAudioVersionAnswer",data.versions)
                //data: audioVersion[].id
                //                    .doubleur:{name,id}
                //                    .name

                $("#characterSelect_"+characterId+" .selectAudioVersion").show();
                if(data.versions)
                {
                    var selectAudioVersion=$("#characterSelect_"+characterId+" .selectAudioVersion select");
                    selectAudioVersion.find("option.audioVersionOption").remove();
                    for(let version of data.versions)
                    {
                        for (let doubler of version.doublers) {
                            selectAudioVersion.append(`<option value=${version.id}>
                            ${doubler.username} | ${version.name}
                            </option>`);
                        }
                        
                    }
                }
            });
        }

        function createNewLineVersion(characterId){
            const token = $('.csrfToken').data('csrf-token');
            const params = { 
                characterId:characterId,
                sceneId:{{scene.id}},
                _csrf: token
            };
            $.post("/lines/createNewVersion",params,function(data){
                console.log(data);
                versionId=data.version.id;
                $(`.selectLineVersion_${characterId} select`).prepend(`<option value="${versionId}">${data.version.name}</option>`);
                $(`.selectLineVersion_${characterId} select`).val(versionId);
                for(let line of data.lines)
                {
                    $(".linePosition_"+line.position).hide();
                    $(".linePosition_"+line.position+".line_newLine").show();
                    $(".linePosition_"+line.position+".line_newLine textarea").attr("id","lineText_"+line.id)
                    $(".linePosition_"+line.position+".line_newLine textarea")
                        .on("input",function(){
                            updateText(line.id);
                        })
                }
            })
        }
    ////////////////////
    // AUDIO VERSION SELECTION
    ////////////////////    
        $(".selectAudioVersion select").on('change',async function(){
            //alert($(this).val()+$(this).data('character-id'))
            var characterId=$(this).data('character-id');
            var audioVersionId=parseInt($(this).val());
            $(".selectAudioVersion_"+characterId+" select").val(audioVersionId);
            console.log($(this));
            switch(audioVersionId){
                case "":
                break;
                case 0:
                console.log("on écoute le robot");
                $(".lineCharacter_"+characterId+" .btnAction").hide();
                $(".lineCharacter_"+characterId+" .btnRobotize").show();
                break;
                case -1:
                console.log("on enregistre sa voix==>Nouvelle version");
                const newAudioVersionId = await createNewAudioVersion(characterId);
                characterToAudioVersion[characterId] = newAudioVersionId;
                console.log(characterToAudioVersion, "s")
                break;
                default:
                characterToAudioVersion[characterId] = audioVersionId;
                console.log(characterToAudioVersion, "s")
                getAudioPaths(audioVersionId,characterId);    
                displayAudioReader(audioVersionId,characterId);
            }
        })


        function getAudioPaths(audioVersionId,characterId){
            const token = $('.csrfToken').data('csrf-token');
            const params = { 
                characterId,
                audioVersionId,
                sceneId:{{scene.id}},
                _csrf: token
            };
            $.get('/audio/getAudiosFromAudioVersion', params, function(data) {
                console.log("getAudiosFromAudioVersionAnswer",data)
                for (let audio of data) {
                    console.log(audio.line.position);
                    globalAudios[audio.line.position] = audio.public_path;
                }
                
                console.log("getAudioVersionAnswer",data)
                displayAudioReader(audioVersionId,characterId,data);
            });

        }
        function displayAudioReader(audioVersionId,characterId){
            $(".lineCharacter_"+characterId+" .btnAction").hide();
            $(".lineCharacter_"+characterId+" .btnPlay").show();
        }




        

        async function createNewAudioVersion(characterId){
            return new Promise((resolve) => {
                const token = $('.csrfToken').data('csrf-token');
            const params = { 
                characterId:characterId,
                sceneId:{{scene.id}},
                _csrf: token
            };
            $.post("/audios/createNewVersion",params,function(version){
                console.log(version);
                versionId=version.id;
                //show microphone next to character's line
                $(".lineCharacter_"+characterId+" .btnAction").hide();
                $(".lineCharacter_"+characterId+" .btnRecordControl").show();
                resolve(version.id)
            })
            })
            
        }

        ////////////////////
        // AUDIO RECORD
        ////////////////////

        const uploadAudio = async (event, objectURL) => {
            const characterID = $(event.target).closest(".line").attr("data-character-id");
            const lineID = event.target.getAttribute("data-line-id");
            const audioVersionID = characterToAudioVersion[characterID];
            console.log("uploading audio!!", objectURL)
            console.log(`Here's the line_id to attach: ${lineID}`);
            event.target.style.display = "none";
            const cancelButton = event.target.parentNode.querySelector(".btnCancel");
            cancelButton.style.display = "none";
            const recordControlButton = event.target.parentNode.querySelector(".btnRecordControl");
            const recordIcon = recordControlButton.querySelector("i");
            recordIcon.classList.remove("fa-play");
            recordIcon.classList.add("fa-microphone");
            event.target.parentNode.querySelector(".btnRecordControl span:nth-child(2)").textContent = "Enregistrer !";
            player.currentTime = 0;
            player.src = "";
            const blob = await fetch(objectURL).then(r => r.blob());
            console.log(blob);
            const form = new FormData();
            form.append("audio", blob);
            form.append("lineId", lineID);
            form.append("versionId", audioVersionID);
            fetch(`${window.location.origin}/audios`, {
                method: "POST",
                headers: {
                    'X-CSRF-Token': $('.csrfToken').data('csrf-token'),
                    /* 'Accept': `${blob.type}`, // FIXME: Not working while file transfer?
                    'Content-Type': `${blob.type}`,*/ 
                    'Content-Transfer-Encoding': 'base64'
                },
                mode: "cors",
                body: form
            }).then(response => {
                if (!response.ok) throw response;
                return response.json();
            }).then((data) => {
                const {versionID, public_path} = data;
                characterToAudioVersion[characterID] = versionID;
                console.log("jsdkajlk")
                // window.location.reload();
            }).catch((err) => {
                console.error(err);
            })

            };

            const cancelRecording = (event, objectURL) => {
            console.log("canceling recording :", objectURL)
            event.target.style.display = "none";
            const uploadButton = event.target.parentNode.querySelector(".btnUpload");
            uploadButton.style.display = "none";
            const recordControlButton = event.target.parentNode.querySelector(".btnRecordControl");
            const recordIcon = recordControlButton.querySelector("i");
            recordIcon.classList.remove("fa-play");
            recordIcon.classList.add("fa-microphone");
            event.target.parentNode.querySelector(".btnRecordControl span:nth-child(2)").textContent = "Enregistrer !";
            player.currentTime = 0;
            player.src = "";
            URL.revokeObjectURL(objectURL); // FIXME Invalid URI. Load of media resource  failed.
            }

            const handleMediaDevice = (event, stream, isFirstRecording) => {
                console.log(event.target);
                const cancelButton = event.target.parentNode.querySelector(".btnCancel");
                const uploadButton = event.target.parentNode.querySelector(".btnUpload");
                const options = {mimeType: "audio/webm"};
                const recordedChunks = [];
                let objectURL;
                mediaRecorder = new MediaRecorder(stream, options);
                console.log(mediaRecorder.mimeType);
                mediaRecorder.addEventListener("dataavailable", function(e) {
                    if (e.data.size > 0) recordedChunks.push(e.data);
                })
                mediaRecorder.addEventListener("stop", (e) => {
                console.log("stopped the media recorder");
                // make the create request here!
                const blob = new Blob(recordedChunks, {type: mediaRecorder.mimeType});
                objectURL = URL.createObjectURL(blob);
                player.src = objectURL;
                // ref: https://stackoverflow.com/questions/11455515/how-to-check-whether-dynamically-attached-event-listener-exists-or-not
                cancelButton.onclick = (_e) => cancelRecording(_e, objectURL);
                uploadButton.onclick = (_e) => uploadAudio(_e, objectURL);

                cancelButton.style.display = "inline";
                uploadButton.style.display = "inline";
                // FIXME how to revoke microphone permissions?

                })
                if (mediaRecorder && mediaRecorder.state !== "recording") mediaRecorder.start();

            };

        const controlAudioRecord = (event) => { 
            const characterID = $(this).closest(".line").attr("data-character-id");
            const cancelButton = event.target.parentNode.querySelector(".btnCancel");
            const uploadButton = event.target.parentNode.querySelector(".btnUpload");
            const icon = event.target.querySelector("i");
            const audioVersion = characterToAudioVersion[characterID];
            const isFirstRecording = !Boolean(audioVersion);

            if (!recording) {
                if (icon.classList.contains("fa-play")) { // playing the recorded one & set upload and delete button
                console.log("now, let's play your recording!")
                player.play();
                } else if (icon.classList.contains("fa-microphone")) {
                event.target.querySelector("span:nth-child(2)").textContent = "Arrêter d'enregistrer !";
                recording = true;
                console.log("starting recording...");
                icon.classList.remove("fa-microphone");
                icon.classList.add("fa-stopwatch");
                event.target.classList.add("glowing");
                console.log(isFirstRecording ? "be prepared! first recording!!" : "not your first one I guess...");
                navigator.mediaDevices.getUserMedia({audio: true, video:false}).then((stream) => handleMediaDevice(event, stream, isFirstRecording))
            }

            } else {
                event.target.querySelector("span:nth-child(2)").textContent = "Lire votre enregistrement !";
                recording = false;
                console.log("stopping recording...");
                // icon.classList.add("fa-microphone");
                icon.classList.remove("fa-stopwatch");
                event.target.classList.remove("glowing");
                if (mediaRecorder && mediaRecorder.state === "recording") mediaRecorder.stop();
                icon.classList.add("fa-play");
            }
            }



            ////////////////////
            // BUTTON LISTENERS
            ////////////////////
            $(".btnPlay").on('click',function(){
                const player = $("#player").get(0);
                const position = $(this).attr("data-position")
                console.log(player);
                if (globalAudios[position]) {
                    player.src = globalAudios[position];
                    player.play();
                }
            });


        function robotSpeak(lineId)
        {
            var text=$("#lineText_"+lineId).val();
            let message = new SpeechSynthesisUtterance(text)
            message.lang = 'fr-FR'
            speechSynthesis.speak(message);
        }


            $(".btnRecordControl").on("click", controlAudioRecord);


















































    function toggleDropdownMenu(objectType,objectId){
        window.event.stopPropagation();
        $("#dropdown-option-container").html("");
        $("#dropdown-menu-"+objectType+"-"+objectId).clone().attr('id', 'currentDropDown').appendTo("#dropdown-option-container");
        $("#dropdown-option-container").show();
        var positionTrigger = $("#dropdown-trigger-"+objectType+"-"+objectId).offset();
        console.log(positionTrigger);
        $("#dropdown-option-container").offset({top:positionTrigger.top+20, left:positionTrigger.left-200})
    }
    $(document).mouseup(function(e) 
    {
        var container = $("#dropdown-option-container, .dropdown-trigger");
        var stuffToHide=$("#dropdown-option-container");
        // if the target of the click isn't the container nor a descendant of the container
        if (!container.is(e.target) && container.has(e.target).length === 0) 
        {
            stuffToHide.hide();
        }
    });

   
    let timer = [];
   
    function updateText(lineId) {
        if(timer[lineId]!=null){
        clearTimeout(timer[lineId]);
        }
        timer[lineId] = setTimeout(()=>{sendUpdateText(lineId)}, 1000);
    }
    function sendUpdateText(lineId){
        console.log("updateText")
        const text=$(`#lineText_${lineId}`).val().trim();
        const token = $('.csrfToken').data('csrf-token');
        const params = { 
            lineId, 
            text,
            _csrf: token
        };
        $.post('/line/updateText', params, function(data) {
            console.log("updateTextData")
            if(data)
            {
                $(`#lineText_${lineId}`).addClass('saved');
                setTimeout(function(){
                    $('.saved').removeClass('saved')
                }, 500);
            }
        });
    }
    
    function updateCharacter(characterId,lineId)
    {
        const token = $('.csrfToken').data('csrf-token');
        const params = { 
            lineId, 
            characterId,
            _csrf: token
        };

        $.post('/line/updateCharacter', params, function(data) {
            if(data)
            {
                $(`#select_character_line_${lineId}`).html("");
                characterClone=$(`#character_line_${characterId}_${lineId}`).clone();
                characterClone.appendTo(`#select_character_line_${lineId}`);
                characterClone.find('.caret').show();
            }
        });
    }

    function auto_grow(element) {
        element.style.height = "30px";
        element.style.minHeight = "60px";
        element.style.height = (element.scrollHeight)+"px";
    }
    [...document.getElementsByClassName('lineText')].forEach((element)=>{
        auto_grow(element)
    })    
    </script>
    
    
@endsection